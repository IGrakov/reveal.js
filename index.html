<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/solarized.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-transition="convex">
					<h1 class="fragment grow">What are microservices?</h1>
					<p class="fragment grow">Presented by Ivan Grakov</p>
					<p>RS School</p>
					<p>January 2020</p>
					<aside class="notes">
						Hello, my dear friends. My name is Ivan Grakov and today I would like to talk about microservices. However, to understand advantages of microservices we first should talk about some other things.
					</aside>
				</section>
				<section data-transition="convex">
					<h1>Industrial Software Development is a team work</h1>
					<aside class="notes">
						And we start with the point how software is developed. If we are talking about industrial software, that is software for real world use, not software as a classroom exercise or something developed for training purposes, in many cases it requires effort of thousands of people and years of development. Even small mobile applications often surprisingly require a team for their creation. So software development in the great majority of cases is not an individual work, it is a teamwork of business analysts, developers, testers, support specialists, project managers and many other people.
					</aside>
				</section>
				<section data-transition="convex">
					<h1>What do we need software for?</h1>
					<h2 class="fragment fade-in">Software development cycle</h2>
					<aside class="notes">
						Now, it is time to say a few words about software development cycle and in broader sense software lifecycle. No matter which methodology is used, waterfall or agile, this cycle is followed explicitly or implicitly when developing any piece of software.

Some people think that software development relates only to development or coding part. Those with deeper understanding add business analysis or planning stage as well as testing to the cycle. However, when software coding is completed and the software passes all tests, it is still far from the end. Purpose of any industrial software is not development of the software. Definitely, there can be exception, but in general, software does not exist per se. It must perform certain purpose. And this purpose can be met only when software is deployed and can be used by users.

In fact, this is not the end, as a need to fix bugs, improve performance, add new functionality makes us to go again to planning stage and repeat everything in cycles till we make decision to stop using and abandon the software.

					</aside>
				</section>
				<section data-transition="convex">
					<h3>Development and operations cycle</h3>
					<div class="r-stack">
						<img src="./examples/assets/DevOps_cycle.png" width="1000"></img>
					</div>
				</section>
				<section data-transition="convex">
					<h3>Monolith architecture overview</h3>
					<div class="r-stack">
						<img class="r-stretch" src="./examples/assets/Monolith_architecture1.png" height="600"></img>
					</div>
					<aside class="notes">
						Now we almost got to microservices. As opposed to microservices architecture the traditional one is the monolith or monolithic architecture. What are the main features of such architecture?
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Monolith architecture features</h3>
					<div class="r-stack">
						<img src="./examples/assets/Monolith_apps_desc.jpeg" height="600"></img>
					</div>
					<aside class="notes">
						Monolith application is a single application that performs all required functionality. It uses one database. It is organized around technology layers, which means that the application is divided into several layers, for instance user interface layer responsible for interaction with users, business logic layer where application logic is performed, persistence layer responsible for long-term storage of data.
What is important from software development cycle point of view is that we must deploy the entire application in one go. 
Also one technology stack is used for the entire application. It influences how quickly we can scale our development capacity. This means that if a company needs to make a modification to an application for whatever reason and there is no free team with competencies in relevant technologies such modification has to be put in a development queue. Free teams with competencies in other technologies cannot be added to the project. In addition, teams need long time to get to know significant part of the application to be able to produce working result and become productive.
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Microservices architecture overview</h3>
					<div class="r-stack">
						<img class="r-stretch" src="./examples/assets/Monolithic_vs_microservices_architecture.png" height="600"></img>
					</div>
					<aside class="notes">
						Finally, we can describe features of microservices architecture. Basically, with microservicies we split our application into a set of small applications interacting with each other, each performing minimal number of functions, ideally just one. 
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Microservices architecture examples</h3>
					<div class="r-stack" class="fragment fade-in-then-out">
						<img class="fragment" src="./examples/assets/Microservices_architecture_at_Uber.png" height="600"></img>
						<img class="fragment" src="./examples/assets/Microservices_architecture_at_Netflix_simplified.png" height="600"></img>
						<img class="fragment" src="./examples/assets/Microservices_architecture_at_Netflix_actual.png" height="600"></img>
						<img class="fragment" src="./examples/assets/Microservices_architecture_at_Amazon.png" height="600"></img>
					</div>
					<aside class="notes">
						Such functions are organized around business capabilities. Here is an example of microservices at well know company Uber. Granularity of microservices can be much finer. For example, at Netflix. And even finer, for example at Amazon. 
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Microservices Pros</h3>
					<table>
						<tr>
							<th>Company</th>
							<th>Deployment Frequency</th>
						</tr>
						<tr>
							<td>Amazon</td>
							<td>Every 11.6 sec</td>
						</tr>
						<tr>
							<td>Netflix</td>
							<td>50 times a day</td>
						</tr>
						<tr>
							<td>Etsy</td>
							<td>60 times a day</td>
						</tr>
					</table>
					<aside class="notes">
						Each microservice is independent of others and stores its data in an independent database. Each microservice is deployed separately, which greatly simplifies deployment process. If we re-deploy a microservice we do not have to stop the entire application and re-deployment process significantly accelerates. Microservices can be also deployed in multiple copies, so when re-deploying one by one copy of a microservice of we can achieve zero downtime of our application. Such deployment may be made very frequent, many times a day. One of the trendsetters Amazon even in 2011 claimed software deployment every 11.6 seconds. Nowadays it is made even more frequently. It means that even smallest change in functionality is being almost in no time thoroughly tested and available to end users. 
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Microservices Pros</h3>
					<div class="r-stack">
						<img src="./examples/assets/Microservices_desc.jpeg" height="600"></img>
					</div>
					<aside class="notes">
						Another advantage of microservices approach is that for each microservice we can choose different stack of technologies independently on what other parts of application are based on. A microservice can be imagined as a black box for which we know only external behavior or its interfaces and do not care what is going on inside. In this case microservices can be developed by independent teams with different technical competences. Development teams become productive much faster as in order to product working result they do not need to know just a small part of application.
					</aside>
				</section>
				<section data-transition="convex">
					<h3>Microservices Cons</h3>
					<ul>
						<li>Complexity of a distributed system for developers</li>
						<li>Requests that span across multiple microservices</li>
						<li>Overhead of communication between services</li>
						<li>Operational compexity</li>
						<li>Full or partial service unavailability</li>
					</ul>
					<aside class="notes">
						Definitely, microservices architecture as any other has its own downsides. Developers must deal with additional complexity of creating a distribute system. Any requests than span across multiple microservices provide additional complexity to coordination between teams. If there are many microservices there is significant overhead of communication between them. Thought deployment can be made much faster and more frequently complexity of the deployment if higher. There is also additional operational complexity once application is deployed. There are additional issues that must be dealt with like partial or full service unavailability, which can be addressed via creation of additional instances of microservices.
					</aside>
				</section>
				<section data-transition="convex">
					<h2>It all depends!</h2>
					<h3 class="fragment fade-in">Thanks for your attention</h3>
					<aside class="notes">
						There is no one fits all recipe. Monolithic architecture is good for small application, for startups with small team and homogeneous technical expertise, for projects with small resource base. However, for development of complex large-scale systems and for companies with multiple teams with heterogeneous skills microservices architecture is a better choice.
					</aside>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
